/*
 * generated by Xtext 2.41.0
 */
package org.xtext.example.easywall.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.easywall.easyWall.EFAndExpression;
import org.xtext.example.easywall.easyWall.EFAssignment;
import org.xtext.example.easywall.easyWall.EFBRacketsExpression;
import org.xtext.example.easywall.easyWall.EFBlock;
import org.xtext.example.easywall.easyWall.EFBoolConstant;
import org.xtext.example.easywall.easyWall.EFEqualExpression;
import org.xtext.example.easywall.easyWall.EFField;
import org.xtext.example.easywall.easyWall.EFFireClass;
import org.xtext.example.easywall.easyWall.EFFunctionCall;
import org.xtext.example.easywall.easyWall.EFHeader;
import org.xtext.example.easywall.easyWall.EFIfStatement;
import org.xtext.example.easywall.easyWall.EFImports;
import org.xtext.example.easywall.easyWall.EFIntConstant;
import org.xtext.example.easywall.easyWall.EFMemberSelection;
import org.xtext.example.easywall.easyWall.EFMethod;
import org.xtext.example.easywall.easyWall.EFNew;
import org.xtext.example.easywall.easyWall.EFNotExpression;
import org.xtext.example.easywall.easyWall.EFOrExpression;
import org.xtext.example.easywall.easyWall.EFParameter;
import org.xtext.example.easywall.easyWall.EFPrimitiveType;
import org.xtext.example.easywall.easyWall.EFRelExpression;
import org.xtext.example.easywall.easyWall.EFReturn;
import org.xtext.example.easywall.easyWall.EFRule;
import org.xtext.example.easywall.easyWall.EFRuleClass;
import org.xtext.example.easywall.easyWall.EFStringConstant;
import org.xtext.example.easywall.easyWall.EFSuper;
import org.xtext.example.easywall.easyWall.EFSymbolRef;
import org.xtext.example.easywall.easyWall.EFThis;
import org.xtext.example.easywall.easyWall.EFVariableDeclaration;
import org.xtext.example.easywall.easyWall.EFfirewall;
import org.xtext.example.easywall.easyWall.EasyWallPackage;
import org.xtext.example.easywall.services.EasyWallGrammarAccess;

@SuppressWarnings("all")
public class EasyWallSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EasyWallGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EasyWallPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EasyWallPackage.EF_AND_EXPRESSION:
				sequence_EFAndExpression(context, (EFAndExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_ASSIGNMENT:
				sequence_EFAssignment(context, (EFAssignment) semanticObject); 
				return; 
			case EasyWallPackage.EFB_RACKETS_EXPRESSION:
				sequence_EFPrimaryExpression(context, (EFBRacketsExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_BLOCK:
				if (rule == grammarAccess.getEFBlockRule()) {
					sequence_EFBlock(context, (EFBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFIfBlockRule()) {
					sequence_EFBlock_EFIfBlock(context, (EFBlock) semanticObject); 
					return; 
				}
				else break;
			case EasyWallPackage.EF_BOOL_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFBoolConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_EQUAL_EXPRESSION:
				sequence_EFEqualExpression(context, (EFEqualExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_FIELD:
				sequence_EFTypedDeclaration(context, (EFField) semanticObject); 
				return; 
			case EasyWallPackage.EF_FIRE_CLASS:
				sequence_EFFireClass(context, (EFFireClass) semanticObject); 
				return; 
			case EasyWallPackage.EF_FUNCTION_CALL:
				sequence_EFPrimaryExpression(context, (EFFunctionCall) semanticObject); 
				return; 
			case EasyWallPackage.EF_HEADER:
				if (rule == grammarAccess.getEFHeaderRule()) {
					sequence_EFHeader(context, (EFHeader) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFProgramRule()) {
					sequence_EFHeader_EFProgram(context, (EFHeader) semanticObject); 
					return; 
				}
				else break;
			case EasyWallPackage.EF_IF_STATEMENT:
				sequence_EFIfStatement(context, (EFIfStatement) semanticObject); 
				return; 
			case EasyWallPackage.EF_IMPORTS:
				sequence_EFImports(context, (EFImports) semanticObject); 
				return; 
			case EasyWallPackage.EF_INT_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFIntConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_MEMBER_SELECTION:
				sequence_EFSelectionExpression(context, (EFMemberSelection) semanticObject); 
				return; 
			case EasyWallPackage.EF_METHOD:
				sequence_EFMethod_EFTypedDeclaration(context, (EFMethod) semanticObject); 
				return; 
			case EasyWallPackage.EF_NEW:
				sequence_EFPrimaryExpression(context, (EFNew) semanticObject); 
				return; 
			case EasyWallPackage.EF_NOT_EXPRESSION:
				sequence_EFUnaryExpression(context, (EFNotExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_OR_EXPRESSION:
				sequence_EFOrExpression(context, (EFOrExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_PARAMETER:
				sequence_EFTypedDeclaration(context, (EFParameter) semanticObject); 
				return; 
			case EasyWallPackage.EF_PRIMITIVE_TYPE:
				sequence_EFPrimaryExpression(context, (EFPrimitiveType) semanticObject); 
				return; 
			case EasyWallPackage.EF_REL_EXPRESSION:
				sequence_EFRelExpression(context, (EFRelExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_RETURN:
				sequence_EFReturn(context, (EFReturn) semanticObject); 
				return; 
			case EasyWallPackage.EF_RULE:
				sequence_EFRule(context, (EFRule) semanticObject); 
				return; 
			case EasyWallPackage.EF_RULE_CLASS:
				sequence_EFRuleClass(context, (EFRuleClass) semanticObject); 
				return; 
			case EasyWallPackage.EF_STRING_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFStringConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_SUPER:
				sequence_EFPrimaryExpression(context, (EFSuper) semanticObject); 
				return; 
			case EasyWallPackage.EF_SYMBOL_REF:
				sequence_EFPrimaryExpression(context, (EFSymbolRef) semanticObject); 
				return; 
			case EasyWallPackage.EF_THIS:
				sequence_EFPrimaryExpression(context, (EFThis) semanticObject); 
				return; 
			case EasyWallPackage.EF_VARIABLE_DECLARATION:
				sequence_EFTypedDeclaration_EFVariableDeclaration(context, (EFVariableDeclaration) semanticObject); 
				return; 
			case EasyWallPackage.EFFIREWALL:
				sequence_EFfirewall(context, (EFfirewall) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFAndExpression
	 *     EFExpression returns EFAndExpression
	 *     EFAssignment returns EFAndExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFAndExpression
	 *     EFOrExpression returns EFAndExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFAndExpression
	 *     EFAndExpression returns EFAndExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFAndExpression
	 *
	 * Constraint:
	 *     (left=EFAndExpression_EFAndExpression_1_0 right=EFEqualExpression)
	 * </pre>
	 */
	protected void sequence_EFAndExpression(ISerializationContext context, EFAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFAndExpressionAccess().getEFAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFAndExpressionAccess().getRightEFEqualExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFAssignment
	 *     EFExpression returns EFAssignment
	 *     EFAssignment returns EFAssignment
	 *
	 * Constraint:
	 *     (left=EFAssignment_EFAssignment_1_0 right=EFAssignment)
	 * </pre>
	 */
	protected void sequence_EFAssignment(ISerializationContext context, EFAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFAssignmentAccess().getEFAssignmentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFAssignmentAccess().getRightEFAssignmentParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFBlock returns EFBlock
	 *
	 * Constraint:
	 *     statements+=EFStatement*
	 * </pre>
	 */
	protected void sequence_EFBlock(ISerializationContext context, EFBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFIfBlock returns EFBlock
	 *
	 * Constraint:
	 *     (statements+=EFStatement+ | statements+=EFStatement)?
	 * </pre>
	 */
	protected void sequence_EFBlock_EFIfBlock(ISerializationContext context, EFBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFEqualExpression
	 *     EFExpression returns EFEqualExpression
	 *     EFAssignment returns EFEqualExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFEqualExpression
	 *     EFOrExpression returns EFEqualExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFEqualExpression
	 *     EFAndExpression returns EFEqualExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFEqualExpression
	 *     EFEqualExpression returns EFEqualExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFEqualExpression
	 *
	 * Constraint:
	 *     (left=EFEqualExpression_EFEqualExpression_1_0 right=EFRelExpression)
	 * </pre>
	 */
	protected void sequence_EFEqualExpression(ISerializationContext context, EFEqualExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFEqualExpressionAccess().getEFEqualExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFEqualExpressionAccess().getRightEFRelExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFFireClass returns EFFireClass
	 *
	 * Constraint:
	 *     (name=ID members+=EFMember*)
	 * </pre>
	 */
	protected void sequence_EFFireClass(ISerializationContext context, EFFireClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFHeader returns EFHeader
	 *
	 * Constraint:
	 *     (name=QualifiedName? imports+=EFImports*)
	 * </pre>
	 */
	protected void sequence_EFHeader(ISerializationContext context, EFHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFProgram returns EFHeader
	 *
	 * Constraint:
	 *     (name=QualifiedName? imports+=EFImports* (rule=EFRule | firewall=EFfirewall))
	 * </pre>
	 */
	protected void sequence_EFHeader_EFProgram(ISerializationContext context, EFHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIfStatement
	 *     EFIfStatement returns EFIfStatement
	 *
	 * Constraint:
	 *     (expression=EFExpression thenBlock=EFIfBlock elseBlock=EFIfBlock?)
	 * </pre>
	 */
	protected void sequence_EFIfStatement(ISerializationContext context, EFIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFImports returns EFImports
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 * </pre>
	 */
	protected void sequence_EFImports(ISerializationContext context, EFImports semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_IMPORTS__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_IMPORTS__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFImportsAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFMember returns EFMethod
	 *     EFMethod returns EFMethod
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType) (params+=EFParameter params+=EFParameter*)? body=EFBlock)
	 * </pre>
	 */
	protected void sequence_EFMethod_EFTypedDeclaration(ISerializationContext context, EFMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFOrExpression
	 *     EFExpression returns EFOrExpression
	 *     EFAssignment returns EFOrExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFOrExpression
	 *     EFOrExpression returns EFOrExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFOrExpression
	 *
	 * Constraint:
	 *     (left=EFOrExpression_EFOrExpression_1_0 right=EFAndExpression)
	 * </pre>
	 */
	protected void sequence_EFOrExpression(ISerializationContext context, EFOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFOrExpressionAccess().getEFOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFOrExpressionAccess().getRightEFAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFBRacketsExpression
	 *     EFExpression returns EFBRacketsExpression
	 *     EFAssignment returns EFBRacketsExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFBRacketsExpression
	 *     EFOrExpression returns EFBRacketsExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFBRacketsExpression
	 *     EFAndExpression returns EFBRacketsExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFBRacketsExpression
	 *     EFEqualExpression returns EFBRacketsExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFBRacketsExpression
	 *     EFRelExpression returns EFBRacketsExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFBRacketsExpression
	 *     EFUnaryExpression returns EFBRacketsExpression
	 *     EFPrimaryExpression returns EFBRacketsExpression
	 *     EFSelectionExpression returns EFBRacketsExpression
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFBRacketsExpression
	 *
	 * Constraint:
	 *     expression=EFExpression
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFBRacketsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFB_RACKETS_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFB_RACKETS_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getExpressionEFExpressionParserRuleCall_7_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFBoolConstant
	 *     EFExpression returns EFBoolConstant
	 *     EFAssignment returns EFBoolConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFBoolConstant
	 *     EFOrExpression returns EFBoolConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFBoolConstant
	 *     EFAndExpression returns EFBoolConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFBoolConstant
	 *     EFEqualExpression returns EFBoolConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFBoolConstant
	 *     EFRelExpression returns EFBoolConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFBoolConstant
	 *     EFUnaryExpression returns EFBoolConstant
	 *     EFPrimaryExpression returns EFBoolConstant
	 *     EFSelectionExpression returns EFBoolConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFBoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFBoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFFunctionCall
	 *     EFExpression returns EFFunctionCall
	 *     EFAssignment returns EFFunctionCall
	 *     EFAssignment.EFAssignment_1_0 returns EFFunctionCall
	 *     EFOrExpression returns EFFunctionCall
	 *     EFOrExpression.EFOrExpression_1_0 returns EFFunctionCall
	 *     EFAndExpression returns EFFunctionCall
	 *     EFAndExpression.EFAndExpression_1_0 returns EFFunctionCall
	 *     EFEqualExpression returns EFFunctionCall
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFFunctionCall
	 *     EFRelExpression returns EFFunctionCall
	 *     EFRelExpression.EFRelExpression_1_0 returns EFFunctionCall
	 *     EFUnaryExpression returns EFFunctionCall
	 *     EFPrimaryExpression returns EFFunctionCall
	 *     EFSelectionExpression returns EFFunctionCall
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFFunctionCall
	 *
	 * Constraint:
	 *     (functionName=QualifiedName (args+=EFExpression args+=EFExpression*)?)
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIntConstant
	 *     EFExpression returns EFIntConstant
	 *     EFAssignment returns EFIntConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFIntConstant
	 *     EFOrExpression returns EFIntConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFIntConstant
	 *     EFAndExpression returns EFIntConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFIntConstant
	 *     EFEqualExpression returns EFIntConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFIntConstant
	 *     EFRelExpression returns EFIntConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFIntConstant
	 *     EFUnaryExpression returns EFIntConstant
	 *     EFPrimaryExpression returns EFIntConstant
	 *     EFSelectionExpression returns EFIntConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFIntConstant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFIntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNew
	 *     EFExpression returns EFNew
	 *     EFAssignment returns EFNew
	 *     EFAssignment.EFAssignment_1_0 returns EFNew
	 *     EFOrExpression returns EFNew
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNew
	 *     EFAndExpression returns EFNew
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNew
	 *     EFEqualExpression returns EFNew
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNew
	 *     EFRelExpression returns EFNew
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNew
	 *     EFUnaryExpression returns EFNew
	 *     EFPrimaryExpression returns EFNew
	 *     EFSelectionExpression returns EFNew
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNew
	 *
	 * Constraint:
	 *     type=[EFRuleClass|QualifiedName]
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNew semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NEW__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NEW__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getTypeEFRuleClassQualifiedNameParserRuleCall_6_2_0_1(), semanticObject.eGet(EasyWallPackage.Literals.EF_NEW__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFPrimitiveType
	 *     EFExpression returns EFPrimitiveType
	 *     EFAssignment returns EFPrimitiveType
	 *     EFAssignment.EFAssignment_1_0 returns EFPrimitiveType
	 *     EFOrExpression returns EFPrimitiveType
	 *     EFOrExpression.EFOrExpression_1_0 returns EFPrimitiveType
	 *     EFAndExpression returns EFPrimitiveType
	 *     EFAndExpression.EFAndExpression_1_0 returns EFPrimitiveType
	 *     EFEqualExpression returns EFPrimitiveType
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFPrimitiveType
	 *     EFRelExpression returns EFPrimitiveType
	 *     EFRelExpression.EFRelExpression_1_0 returns EFPrimitiveType
	 *     EFUnaryExpression returns EFPrimitiveType
	 *     EFPrimaryExpression returns EFPrimitiveType
	 *     EFSelectionExpression returns EFPrimitiveType
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFPrimitiveType
	 *
	 * Constraint:
	 *     type=EFNetworkNativeType
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_PRIMITIVE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_PRIMITIVE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getTypeEFNetworkNativeTypeEnumRuleCall_3_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFStringConstant
	 *     EFExpression returns EFStringConstant
	 *     EFAssignment returns EFStringConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFStringConstant
	 *     EFOrExpression returns EFStringConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFStringConstant
	 *     EFAndExpression returns EFStringConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFStringConstant
	 *     EFEqualExpression returns EFStringConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFStringConstant
	 *     EFRelExpression returns EFStringConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFStringConstant
	 *     EFUnaryExpression returns EFStringConstant
	 *     EFPrimaryExpression returns EFStringConstant
	 *     EFSelectionExpression returns EFStringConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFStringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFStringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFSuper
	 *     EFExpression returns EFSuper
	 *     EFAssignment returns EFSuper
	 *     EFAssignment.EFAssignment_1_0 returns EFSuper
	 *     EFOrExpression returns EFSuper
	 *     EFOrExpression.EFOrExpression_1_0 returns EFSuper
	 *     EFAndExpression returns EFSuper
	 *     EFAndExpression.EFAndExpression_1_0 returns EFSuper
	 *     EFEqualExpression returns EFSuper
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFSuper
	 *     EFRelExpression returns EFSuper
	 *     EFRelExpression.EFRelExpression_1_0 returns EFSuper
	 *     EFUnaryExpression returns EFSuper
	 *     EFPrimaryExpression returns EFSuper
	 *     EFSelectionExpression returns EFSuper
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFSuper
	 *
	 * Constraint:
	 *     {EFSuper}
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFSuper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFSymbolRef
	 *     EFExpression returns EFSymbolRef
	 *     EFAssignment returns EFSymbolRef
	 *     EFAssignment.EFAssignment_1_0 returns EFSymbolRef
	 *     EFOrExpression returns EFSymbolRef
	 *     EFOrExpression.EFOrExpression_1_0 returns EFSymbolRef
	 *     EFAndExpression returns EFSymbolRef
	 *     EFAndExpression.EFAndExpression_1_0 returns EFSymbolRef
	 *     EFEqualExpression returns EFSymbolRef
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFSymbolRef
	 *     EFRelExpression returns EFSymbolRef
	 *     EFRelExpression.EFRelExpression_1_0 returns EFSymbolRef
	 *     EFUnaryExpression returns EFSymbolRef
	 *     EFPrimaryExpression returns EFSymbolRef
	 *     EFSelectionExpression returns EFSymbolRef
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFSymbolRef
	 *
	 * Constraint:
	 *     symbol=QualifiedName
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFSymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_SYMBOL_REF__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_SYMBOL_REF__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getSymbolQualifiedNameParserRuleCall_9_1_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFThis
	 *     EFExpression returns EFThis
	 *     EFAssignment returns EFThis
	 *     EFAssignment.EFAssignment_1_0 returns EFThis
	 *     EFOrExpression returns EFThis
	 *     EFOrExpression.EFOrExpression_1_0 returns EFThis
	 *     EFAndExpression returns EFThis
	 *     EFAndExpression.EFAndExpression_1_0 returns EFThis
	 *     EFEqualExpression returns EFThis
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFThis
	 *     EFRelExpression returns EFThis
	 *     EFRelExpression.EFRelExpression_1_0 returns EFThis
	 *     EFUnaryExpression returns EFThis
	 *     EFPrimaryExpression returns EFThis
	 *     EFSelectionExpression returns EFThis
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFThis
	 *
	 * Constraint:
	 *     {EFThis}
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFThis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFRelExpression
	 *     EFExpression returns EFRelExpression
	 *     EFAssignment returns EFRelExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFRelExpression
	 *     EFOrExpression returns EFRelExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFRelExpression
	 *     EFAndExpression returns EFRelExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFRelExpression
	 *     EFEqualExpression returns EFRelExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFRelExpression
	 *     EFRelExpression returns EFRelExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFRelExpression
	 *
	 * Constraint:
	 *     (left=EFRelExpression_EFRelExpression_1_0 right=EFUnaryExpression)
	 * </pre>
	 */
	protected void sequence_EFRelExpression(ISerializationContext context, EFRelExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFRelExpressionAccess().getEFRelExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFRelExpressionAccess().getRightEFUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFReturn
	 *     EFReturn returns EFReturn
	 *
	 * Constraint:
	 *     expression=EFExpression
	 * </pre>
	 */
	protected void sequence_EFReturn(ISerializationContext context, EFReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFReturnAccess().getExpressionEFExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFRuleClass returns EFRuleClass
	 *
	 * Constraint:
	 *     (name=ID type=EFRulesTypes members+=EFMember*)
	 * </pre>
	 */
	protected void sequence_EFRuleClass(ISerializationContext context, EFRuleClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFRule returns EFRule
	 *
	 * Constraint:
	 *     rules=EFRuleClass
	 * </pre>
	 */
	protected void sequence_EFRule(ISerializationContext context, EFRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_RULE__RULES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_RULE__RULES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFRuleAccess().getRulesEFRuleClassParserRuleCall_0(), semanticObject.getRules());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFSelectionExpression returns EFMemberSelection
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFMemberSelection
	 *
	 * Constraint:
	 *     (receiver=EFSelectionExpression_EFMemberSelection_1_0 member=[EFMember|ID] (args+=EFExpression args+=EFExpression*)?)
	 * </pre>
	 */
	protected void sequence_EFSelectionExpression(ISerializationContext context, EFMemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFMember returns EFField
	 *     EFField returns EFField
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType))
	 * </pre>
	 */
	protected void sequence_EFTypedDeclaration(ISerializationContext context, EFField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFParameter returns EFParameter
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType))
	 * </pre>
	 */
	protected void sequence_EFTypedDeclaration(ISerializationContext context, EFParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFVariableDeclaration returns EFVariableDeclaration
	 *     EFStatement returns EFVariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType) expression=EFExpression)
	 * </pre>
	 */
	protected void sequence_EFTypedDeclaration_EFVariableDeclaration(ISerializationContext context, EFVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNotExpression
	 *     EFExpression returns EFNotExpression
	 *     EFAssignment returns EFNotExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFNotExpression
	 *     EFOrExpression returns EFNotExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNotExpression
	 *     EFAndExpression returns EFNotExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNotExpression
	 *     EFEqualExpression returns EFNotExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNotExpression
	 *     EFRelExpression returns EFNotExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNotExpression
	 *     EFUnaryExpression returns EFNotExpression
	 *
	 * Constraint:
	 *     expression=EFUnaryExpression
	 * </pre>
	 */
	protected void sequence_EFUnaryExpression(ISerializationContext context, EFNotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFUnaryExpressionAccess().getExpressionEFUnaryExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFfirewall returns EFfirewall
	 *
	 * Constraint:
	 *     firewall=EFFireClass
	 * </pre>
	 */
	protected void sequence_EFfirewall(ISerializationContext context, EFfirewall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFFIREWALL__FIREWALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFFIREWALL__FIREWALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFfirewallAccess().getFirewallEFFireClassParserRuleCall_0(), semanticObject.getFirewall());
		feeder.finish();
	}
	
	
}
