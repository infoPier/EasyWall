/*
 * generated by Xtext 2.41.0
 */
package org.xtext.example.easywall.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.easywall.easyWall.EFAndExpression;
import org.xtext.example.easywall.easyWall.EFApplicationProtocolConstant;
import org.xtext.example.easywall.easyWall.EFAssignment;
import org.xtext.example.easywall.easyWall.EFBRacketsExpression;
import org.xtext.example.easywall.easyWall.EFBlock;
import org.xtext.example.easywall.easyWall.EFBoolConstant;
import org.xtext.example.easywall.easyWall.EFDirectionConstant;
import org.xtext.example.easywall.easyWall.EFEqualExpression;
import org.xtext.example.easywall.easyWall.EFExpression;
import org.xtext.example.easywall.easyWall.EFField;
import org.xtext.example.easywall.easyWall.EFFireClass;
import org.xtext.example.easywall.easyWall.EFFunctionCall;
import org.xtext.example.easywall.easyWall.EFHeader;
import org.xtext.example.easywall.easyWall.EFIPv4Constant;
import org.xtext.example.easywall.easyWall.EFIPv6Constant;
import org.xtext.example.easywall.easyWall.EFIfStatement;
import org.xtext.example.easywall.easyWall.EFImports;
import org.xtext.example.easywall.easyWall.EFIntConstant;
import org.xtext.example.easywall.easyWall.EFMemberSelection;
import org.xtext.example.easywall.easyWall.EFMethod;
import org.xtext.example.easywall.easyWall.EFNetmaskConstant;
import org.xtext.example.easywall.easyWall.EFNetportConstant;
import org.xtext.example.easywall.easyWall.EFNetworkConstant;
import org.xtext.example.easywall.easyWall.EFNetworkProtocolConstant;
import org.xtext.example.easywall.easyWall.EFNew;
import org.xtext.example.easywall.easyWall.EFNotExpression;
import org.xtext.example.easywall.easyWall.EFOrExpression;
import org.xtext.example.easywall.easyWall.EFParameter;
import org.xtext.example.easywall.easyWall.EFPrimitiveType;
import org.xtext.example.easywall.easyWall.EFRelExpression;
import org.xtext.example.easywall.easyWall.EFReturn;
import org.xtext.example.easywall.easyWall.EFRule;
import org.xtext.example.easywall.easyWall.EFRuleClass;
import org.xtext.example.easywall.easyWall.EFStringConstant;
import org.xtext.example.easywall.easyWall.EFSuper;
import org.xtext.example.easywall.easyWall.EFSymbolRef;
import org.xtext.example.easywall.easyWall.EFThis;
import org.xtext.example.easywall.easyWall.EFTransportProtocolConstant;
import org.xtext.example.easywall.easyWall.EFVariableDeclaration;
import org.xtext.example.easywall.easyWall.EFfirewall;
import org.xtext.example.easywall.easyWall.EasyWallPackage;
import org.xtext.example.easywall.services.EasyWallGrammarAccess;

@SuppressWarnings("all")
public class EasyWallSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EasyWallGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EasyWallPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EasyWallPackage.EF_AND_EXPRESSION:
				sequence_EFAndExpression(context, (EFAndExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_APPLICATION_PROTOCOL_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFApplicationProtocolConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_ASSIGNMENT:
				sequence_EFAssignment(context, (EFAssignment) semanticObject); 
				return; 
			case EasyWallPackage.EFB_RACKETS_EXPRESSION:
				sequence_EFPrimaryExpression(context, (EFBRacketsExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_BLOCK:
				if (rule == grammarAccess.getEFBlockRule()) {
					sequence_EFBlock(context, (EFBlock) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFIfBlockRule()) {
					sequence_EFBlock_EFIfBlock(context, (EFBlock) semanticObject); 
					return; 
				}
				else break;
			case EasyWallPackage.EF_BOOL_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFBoolConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_DIRECTION_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFDirectionConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_EQUAL_EXPRESSION:
				sequence_EFEqualExpression(context, (EFEqualExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_EXPRESSION:
				if (rule == grammarAccess.getEFIPv4SYNTAXRule()) {
					sequence_EFIPv4SYNTAX(context, (EFExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFNetmaskSYNTAXRule()) {
					sequence_EFNetmaskSYNTAX(context, (EFExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFNetportSYNTAXRule()) {
					sequence_EFNetportSYNTAX(context, (EFExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFNetworkSYNTAXRule()) {
					sequence_EFNetworkSYNTAX(context, (EFExpression) semanticObject); 
					return; 
				}
				else break;
			case EasyWallPackage.EF_FIELD:
				sequence_EFField_EFTypedDeclaration(context, (EFField) semanticObject); 
				return; 
			case EasyWallPackage.EF_FIRE_CLASS:
				sequence_EFFireClass(context, (EFFireClass) semanticObject); 
				return; 
			case EasyWallPackage.EF_FUNCTION_CALL:
				sequence_EFPrimaryExpression(context, (EFFunctionCall) semanticObject); 
				return; 
			case EasyWallPackage.EF_HEADER:
				if (rule == grammarAccess.getEFHeaderRule()) {
					sequence_EFHeader(context, (EFHeader) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEFProgramRule()) {
					sequence_EFHeader_EFProgram(context, (EFHeader) semanticObject); 
					return; 
				}
				else break;
			case EasyWallPackage.EFI_PV4_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFIPv4Constant) semanticObject); 
				return; 
			case EasyWallPackage.EFI_PV6_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFIPv6Constant) semanticObject); 
				return; 
			case EasyWallPackage.EF_IF_STATEMENT:
				sequence_EFIfStatement(context, (EFIfStatement) semanticObject); 
				return; 
			case EasyWallPackage.EF_IMPORTS:
				sequence_EFImports(context, (EFImports) semanticObject); 
				return; 
			case EasyWallPackage.EF_INT_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFIntConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_MEMBER_SELECTION:
				sequence_EFSelectionExpression(context, (EFMemberSelection) semanticObject); 
				return; 
			case EasyWallPackage.EF_METHOD:
				sequence_EFMethod_EFTypedDeclaration(context, (EFMethod) semanticObject); 
				return; 
			case EasyWallPackage.EF_NETMASK_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFNetmaskConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_NETPORT_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFNetportConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_NETWORK_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFNetworkConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_NETWORK_PROTOCOL_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFNetworkProtocolConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_NEW:
				sequence_EFPrimaryExpression(context, (EFNew) semanticObject); 
				return; 
			case EasyWallPackage.EF_NOT_EXPRESSION:
				sequence_EFUnaryExpression(context, (EFNotExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_OR_EXPRESSION:
				sequence_EFOrExpression(context, (EFOrExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_PARAMETER:
				sequence_EFTypedDeclaration(context, (EFParameter) semanticObject); 
				return; 
			case EasyWallPackage.EF_PRIMITIVE_TYPE:
				sequence_EFPrimaryExpression(context, (EFPrimitiveType) semanticObject); 
				return; 
			case EasyWallPackage.EF_REL_EXPRESSION:
				sequence_EFRelExpression(context, (EFRelExpression) semanticObject); 
				return; 
			case EasyWallPackage.EF_RETURN:
				sequence_EFReturn(context, (EFReturn) semanticObject); 
				return; 
			case EasyWallPackage.EF_RULE:
				sequence_EFRule(context, (EFRule) semanticObject); 
				return; 
			case EasyWallPackage.EF_RULE_CLASS:
				sequence_EFRuleClass(context, (EFRuleClass) semanticObject); 
				return; 
			case EasyWallPackage.EF_STRING_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFStringConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_SUPER:
				sequence_EFPrimaryExpression(context, (EFSuper) semanticObject); 
				return; 
			case EasyWallPackage.EF_SYMBOL_REF:
				sequence_EFPrimaryExpression(context, (EFSymbolRef) semanticObject); 
				return; 
			case EasyWallPackage.EF_THIS:
				sequence_EFPrimaryExpression(context, (EFThis) semanticObject); 
				return; 
			case EasyWallPackage.EF_TRANSPORT_PROTOCOL_CONSTANT:
				sequence_EFPrimaryExpression(context, (EFTransportProtocolConstant) semanticObject); 
				return; 
			case EasyWallPackage.EF_VARIABLE_DECLARATION:
				sequence_EFTypedDeclaration_EFVariableDeclaration(context, (EFVariableDeclaration) semanticObject); 
				return; 
			case EasyWallPackage.EFFIREWALL:
				sequence_EFfirewall(context, (EFfirewall) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFAndExpression
	 *     EFExpression returns EFAndExpression
	 *     EFAssignment returns EFAndExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFAndExpression
	 *     EFOrExpression returns EFAndExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFAndExpression
	 *     EFAndExpression returns EFAndExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFAndExpression
	 *
	 * Constraint:
	 *     (left=EFAndExpression_EFAndExpression_1_0 right=EFEqualExpression)
	 * </pre>
	 */
	protected void sequence_EFAndExpression(ISerializationContext context, EFAndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFAndExpressionAccess().getEFAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFAndExpressionAccess().getRightEFEqualExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFAssignment
	 *     EFExpression returns EFAssignment
	 *     EFAssignment returns EFAssignment
	 *
	 * Constraint:
	 *     (left=EFAssignment_EFAssignment_1_0 right=EFAssignment)
	 * </pre>
	 */
	protected void sequence_EFAssignment(ISerializationContext context, EFAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_ASSIGNMENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFAssignmentAccess().getEFAssignmentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFAssignmentAccess().getRightEFAssignmentParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFBlock returns EFBlock
	 *
	 * Constraint:
	 *     statements+=EFStatement*
	 * </pre>
	 */
	protected void sequence_EFBlock(ISerializationContext context, EFBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFIfBlock returns EFBlock
	 *
	 * Constraint:
	 *     (statements+=EFStatement+ | statements+=EFStatement)?
	 * </pre>
	 */
	protected void sequence_EFBlock_EFIfBlock(ISerializationContext context, EFBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFEqualExpression
	 *     EFExpression returns EFEqualExpression
	 *     EFAssignment returns EFEqualExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFEqualExpression
	 *     EFOrExpression returns EFEqualExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFEqualExpression
	 *     EFAndExpression returns EFEqualExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFEqualExpression
	 *     EFEqualExpression returns EFEqualExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFEqualExpression
	 *
	 * Constraint:
	 *     (left=EFEqualExpression_EFEqualExpression_1_0 right=EFRelExpression)
	 * </pre>
	 */
	protected void sequence_EFEqualExpression(ISerializationContext context, EFEqualExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EQUAL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFEqualExpressionAccess().getEFEqualExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFEqualExpressionAccess().getRightEFRelExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFMember returns EFField
	 *     EFField returns EFField
	 *     EFStatement returns EFField
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType) expression=EFExpression?)
	 * </pre>
	 */
	protected void sequence_EFField_EFTypedDeclaration(ISerializationContext context, EFField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFFireClass returns EFFireClass
	 *
	 * Constraint:
	 *     (name=ID members+=EFMember*)
	 * </pre>
	 */
	protected void sequence_EFFireClass(ISerializationContext context, EFFireClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFHeader returns EFHeader
	 *
	 * Constraint:
	 *     (name=QualifiedName? imports+=EFImports*)
	 * </pre>
	 */
	protected void sequence_EFHeader(ISerializationContext context, EFHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFProgram returns EFHeader
	 *
	 * Constraint:
	 *     (name=QualifiedName? imports+=EFImports* (rule=EFRule | firewall=EFfirewall))
	 * </pre>
	 */
	protected void sequence_EFHeader_EFProgram(ISerializationContext context, EFHeader semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFIPv4SYNTAX returns EFExpression
	 *
	 * Constraint:
	 *     ((first=INT second=INT third=INT fourth=INT) | any='any' | localhost='localhost')
	 * </pre>
	 */
	protected void sequence_EFIPv4SYNTAX(ISerializationContext context, EFExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIfStatement
	 *     EFIfStatement returns EFIfStatement
	 *
	 * Constraint:
	 *     (expression=EFExpression thenBlock=EFIfBlock elseBlock=EFIfBlock?)
	 * </pre>
	 */
	protected void sequence_EFIfStatement(ISerializationContext context, EFIfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFImports returns EFImports
	 *
	 * Constraint:
	 *     importedNamespace=QualifiedNameWithWildcard
	 * </pre>
	 */
	protected void sequence_EFImports(ISerializationContext context, EFImports semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_IMPORTS__IMPORTED_NAMESPACE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_IMPORTS__IMPORTED_NAMESPACE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFImportsAccess().getImportedNamespaceQualifiedNameWithWildcardParserRuleCall_1_0(), semanticObject.getImportedNamespace());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFMember returns EFMethod
	 *     EFMethod returns EFMethod
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType) (params+=EFParameter params+=EFParameter*)? body=EFBlock)
	 * </pre>
	 */
	protected void sequence_EFMethod_EFTypedDeclaration(ISerializationContext context, EFMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFNetmaskSYNTAX returns EFExpression
	 *
	 * Constraint:
	 *     subnet=INT
	 * </pre>
	 */
	protected void sequence_EFNetmaskSYNTAX(ISerializationContext context, EFExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EXPRESSION__SUBNET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EXPRESSION__SUBNET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFNetmaskSYNTAXAccess().getSubnetINTTerminalRuleCall_1_0(), semanticObject.getSubnet());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFNetportSYNTAX returns EFExpression
	 *
	 * Constraint:
	 *     netport=INT
	 * </pre>
	 */
	protected void sequence_EFNetportSYNTAX(ISerializationContext context, EFExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_EXPRESSION__NETPORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_EXPRESSION__NETPORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFNetportSYNTAXAccess().getNetportINTTerminalRuleCall_1_0(), semanticObject.getNetport());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFNetworkSYNTAX returns EFExpression
	 *
	 * Constraint:
	 *     ((varip=ID varnetmask=ID) | (rawip=EFIPv4SYNTAX rawnetmask=INT) | (rawip=EFIPv4SYNTAX varnetmask=ID) | (varip=ID rawnetmask=INT))
	 * </pre>
	 */
	protected void sequence_EFNetworkSYNTAX(ISerializationContext context, EFExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFOrExpression
	 *     EFExpression returns EFOrExpression
	 *     EFAssignment returns EFOrExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFOrExpression
	 *     EFOrExpression returns EFOrExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFOrExpression
	 *
	 * Constraint:
	 *     (left=EFOrExpression_EFOrExpression_1_0 right=EFAndExpression)
	 * </pre>
	 */
	protected void sequence_EFOrExpression(ISerializationContext context, EFOrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFOrExpressionAccess().getEFOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFOrExpressionAccess().getRightEFAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFApplicationProtocolConstant
	 *     EFExpression returns EFApplicationProtocolConstant
	 *     EFAssignment returns EFApplicationProtocolConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFApplicationProtocolConstant
	 *     EFOrExpression returns EFApplicationProtocolConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFApplicationProtocolConstant
	 *     EFAndExpression returns EFApplicationProtocolConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFApplicationProtocolConstant
	 *     EFEqualExpression returns EFApplicationProtocolConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFApplicationProtocolConstant
	 *     EFRelExpression returns EFApplicationProtocolConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFApplicationProtocolConstant
	 *     EFUnaryExpression returns EFApplicationProtocolConstant
	 *     EFPrimaryExpression returns EFApplicationProtocolConstant
	 *     EFSelectionExpression returns EFApplicationProtocolConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFApplicationProtocolConstant
	 *
	 * Constraint:
	 *     protocol=APPLICATIONLAYERPROTOCOL
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFApplicationProtocolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_APPLICATION_PROTOCOL_CONSTANT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_APPLICATION_PROTOCOL_CONSTANT__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getProtocolAPPLICATIONLAYERPROTOCOLEnumRuleCall_7_1_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFBRacketsExpression
	 *     EFExpression returns EFBRacketsExpression
	 *     EFAssignment returns EFBRacketsExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFBRacketsExpression
	 *     EFOrExpression returns EFBRacketsExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFBRacketsExpression
	 *     EFAndExpression returns EFBRacketsExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFBRacketsExpression
	 *     EFEqualExpression returns EFBRacketsExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFBRacketsExpression
	 *     EFRelExpression returns EFBRacketsExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFBRacketsExpression
	 *     EFUnaryExpression returns EFBRacketsExpression
	 *     EFPrimaryExpression returns EFBRacketsExpression
	 *     EFSelectionExpression returns EFBRacketsExpression
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFBRacketsExpression
	 *
	 * Constraint:
	 *     expression=EFExpression
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFBRacketsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFB_RACKETS_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFB_RACKETS_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getExpressionEFExpressionParserRuleCall_16_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFBoolConstant
	 *     EFExpression returns EFBoolConstant
	 *     EFAssignment returns EFBoolConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFBoolConstant
	 *     EFOrExpression returns EFBoolConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFBoolConstant
	 *     EFAndExpression returns EFBoolConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFBoolConstant
	 *     EFEqualExpression returns EFBoolConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFBoolConstant
	 *     EFRelExpression returns EFBoolConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFBoolConstant
	 *     EFUnaryExpression returns EFBoolConstant
	 *     EFPrimaryExpression returns EFBoolConstant
	 *     EFSelectionExpression returns EFBoolConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFBoolConstant
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFBoolConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFDirectionConstant
	 *     EFExpression returns EFDirectionConstant
	 *     EFAssignment returns EFDirectionConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFDirectionConstant
	 *     EFOrExpression returns EFDirectionConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFDirectionConstant
	 *     EFAndExpression returns EFDirectionConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFDirectionConstant
	 *     EFEqualExpression returns EFDirectionConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFDirectionConstant
	 *     EFRelExpression returns EFDirectionConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFDirectionConstant
	 *     EFUnaryExpression returns EFDirectionConstant
	 *     EFPrimaryExpression returns EFDirectionConstant
	 *     EFSelectionExpression returns EFDirectionConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFDirectionConstant
	 *
	 * Constraint:
	 *     direction=EFDirectionNativeType
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFDirectionConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_DIRECTION_CONSTANT__DIRECTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_DIRECTION_CONSTANT__DIRECTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getDirectionEFDirectionNativeTypeEnumRuleCall_4_1_0(), semanticObject.getDirection());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFFunctionCall
	 *     EFExpression returns EFFunctionCall
	 *     EFAssignment returns EFFunctionCall
	 *     EFAssignment.EFAssignment_1_0 returns EFFunctionCall
	 *     EFOrExpression returns EFFunctionCall
	 *     EFOrExpression.EFOrExpression_1_0 returns EFFunctionCall
	 *     EFAndExpression returns EFFunctionCall
	 *     EFAndExpression.EFAndExpression_1_0 returns EFFunctionCall
	 *     EFEqualExpression returns EFFunctionCall
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFFunctionCall
	 *     EFRelExpression returns EFFunctionCall
	 *     EFRelExpression.EFRelExpression_1_0 returns EFFunctionCall
	 *     EFUnaryExpression returns EFFunctionCall
	 *     EFPrimaryExpression returns EFFunctionCall
	 *     EFSelectionExpression returns EFFunctionCall
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFFunctionCall
	 *
	 * Constraint:
	 *     (functionName=QualifiedName (args+=EFExpression args+=EFExpression*)?)
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFFunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIPv4Constant
	 *     EFExpression returns EFIPv4Constant
	 *     EFAssignment returns EFIPv4Constant
	 *     EFAssignment.EFAssignment_1_0 returns EFIPv4Constant
	 *     EFOrExpression returns EFIPv4Constant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFIPv4Constant
	 *     EFAndExpression returns EFIPv4Constant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFIPv4Constant
	 *     EFEqualExpression returns EFIPv4Constant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFIPv4Constant
	 *     EFRelExpression returns EFIPv4Constant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFIPv4Constant
	 *     EFUnaryExpression returns EFIPv4Constant
	 *     EFPrimaryExpression returns EFIPv4Constant
	 *     EFSelectionExpression returns EFIPv4Constant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFIPv4Constant
	 *
	 * Constraint:
	 *     ipv4=EFIPv4SYNTAX
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFIPv4Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFI_PV4_CONSTANT__IPV4) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFI_PV4_CONSTANT__IPV4));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getIpv4EFIPv4SYNTAXParserRuleCall_9_1_0(), semanticObject.getIpv4());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIPv6Constant
	 *     EFExpression returns EFIPv6Constant
	 *     EFAssignment returns EFIPv6Constant
	 *     EFAssignment.EFAssignment_1_0 returns EFIPv6Constant
	 *     EFOrExpression returns EFIPv6Constant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFIPv6Constant
	 *     EFAndExpression returns EFIPv6Constant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFIPv6Constant
	 *     EFEqualExpression returns EFIPv6Constant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFIPv6Constant
	 *     EFRelExpression returns EFIPv6Constant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFIPv6Constant
	 *     EFUnaryExpression returns EFIPv6Constant
	 *     EFPrimaryExpression returns EFIPv6Constant
	 *     EFSelectionExpression returns EFIPv6Constant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFIPv6Constant
	 *
	 * Constraint:
	 *     ipv6=EFIPV6SYNTAX
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFIPv6Constant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFI_PV6_CONSTANT__IPV6) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFI_PV6_CONSTANT__IPV6));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getIpv6EFIPV6SYNTAXTerminalRuleCall_8_1_0(), semanticObject.getIpv6());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFIntConstant
	 *     EFExpression returns EFIntConstant
	 *     EFAssignment returns EFIntConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFIntConstant
	 *     EFOrExpression returns EFIntConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFIntConstant
	 *     EFAndExpression returns EFIntConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFIntConstant
	 *     EFEqualExpression returns EFIntConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFIntConstant
	 *     EFRelExpression returns EFIntConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFIntConstant
	 *     EFUnaryExpression returns EFIntConstant
	 *     EFPrimaryExpression returns EFIntConstant
	 *     EFSelectionExpression returns EFIntConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFIntConstant
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFIntConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_INT_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_INT_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getValueINTTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNetmaskConstant
	 *     EFExpression returns EFNetmaskConstant
	 *     EFAssignment returns EFNetmaskConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFNetmaskConstant
	 *     EFOrExpression returns EFNetmaskConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNetmaskConstant
	 *     EFAndExpression returns EFNetmaskConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNetmaskConstant
	 *     EFEqualExpression returns EFNetmaskConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNetmaskConstant
	 *     EFRelExpression returns EFNetmaskConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNetmaskConstant
	 *     EFUnaryExpression returns EFNetmaskConstant
	 *     EFPrimaryExpression returns EFNetmaskConstant
	 *     EFSelectionExpression returns EFNetmaskConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNetmaskConstant
	 *
	 * Constraint:
	 *     netmask=EFNetmaskSYNTAX
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNetmaskConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NETMASK_CONSTANT__NETMASK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NETMASK_CONSTANT__NETMASK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getNetmaskEFNetmaskSYNTAXParserRuleCall_12_1_0(), semanticObject.getNetmask());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNetportConstant
	 *     EFExpression returns EFNetportConstant
	 *     EFAssignment returns EFNetportConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFNetportConstant
	 *     EFOrExpression returns EFNetportConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNetportConstant
	 *     EFAndExpression returns EFNetportConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNetportConstant
	 *     EFEqualExpression returns EFNetportConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNetportConstant
	 *     EFRelExpression returns EFNetportConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNetportConstant
	 *     EFUnaryExpression returns EFNetportConstant
	 *     EFPrimaryExpression returns EFNetportConstant
	 *     EFSelectionExpression returns EFNetportConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNetportConstant
	 *
	 * Constraint:
	 *     port=EFNetportSYNTAX
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNetportConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NETPORT_CONSTANT__PORT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NETPORT_CONSTANT__PORT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getPortEFNetportSYNTAXParserRuleCall_11_1_0(), semanticObject.getPort());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNetworkConstant
	 *     EFExpression returns EFNetworkConstant
	 *     EFAssignment returns EFNetworkConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFNetworkConstant
	 *     EFOrExpression returns EFNetworkConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNetworkConstant
	 *     EFAndExpression returns EFNetworkConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNetworkConstant
	 *     EFEqualExpression returns EFNetworkConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNetworkConstant
	 *     EFRelExpression returns EFNetworkConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNetworkConstant
	 *     EFUnaryExpression returns EFNetworkConstant
	 *     EFPrimaryExpression returns EFNetworkConstant
	 *     EFSelectionExpression returns EFNetworkConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNetworkConstant
	 *
	 * Constraint:
	 *     network=EFNetworkSYNTAX
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNetworkConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NETWORK_CONSTANT__NETWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NETWORK_CONSTANT__NETWORK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getNetworkEFNetworkSYNTAXParserRuleCall_10_1_0(), semanticObject.getNetwork());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNetworkProtocolConstant
	 *     EFExpression returns EFNetworkProtocolConstant
	 *     EFAssignment returns EFNetworkProtocolConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFNetworkProtocolConstant
	 *     EFOrExpression returns EFNetworkProtocolConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNetworkProtocolConstant
	 *     EFAndExpression returns EFNetworkProtocolConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNetworkProtocolConstant
	 *     EFEqualExpression returns EFNetworkProtocolConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNetworkProtocolConstant
	 *     EFRelExpression returns EFNetworkProtocolConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNetworkProtocolConstant
	 *     EFUnaryExpression returns EFNetworkProtocolConstant
	 *     EFPrimaryExpression returns EFNetworkProtocolConstant
	 *     EFSelectionExpression returns EFNetworkProtocolConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNetworkProtocolConstant
	 *
	 * Constraint:
	 *     protocol=NETWORKLAYERPROTOCOL
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNetworkProtocolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NETWORK_PROTOCOL_CONSTANT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NETWORK_PROTOCOL_CONSTANT__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getProtocolNETWORKLAYERPROTOCOLEnumRuleCall_5_1_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNew
	 *     EFExpression returns EFNew
	 *     EFAssignment returns EFNew
	 *     EFAssignment.EFAssignment_1_0 returns EFNew
	 *     EFOrExpression returns EFNew
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNew
	 *     EFAndExpression returns EFNew
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNew
	 *     EFEqualExpression returns EFNew
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNew
	 *     EFRelExpression returns EFNew
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNew
	 *     EFUnaryExpression returns EFNew
	 *     EFPrimaryExpression returns EFNew
	 *     EFSelectionExpression returns EFNew
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFNew
	 *
	 * Constraint:
	 *     type=[EFRuleClass|QualifiedName]
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFNew semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NEW__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NEW__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getTypeEFRuleClassQualifiedNameParserRuleCall_15_2_0_1(), semanticObject.eGet(EasyWallPackage.Literals.EF_NEW__TYPE, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFPrimitiveType
	 *     EFExpression returns EFPrimitiveType
	 *     EFAssignment returns EFPrimitiveType
	 *     EFAssignment.EFAssignment_1_0 returns EFPrimitiveType
	 *     EFOrExpression returns EFPrimitiveType
	 *     EFOrExpression.EFOrExpression_1_0 returns EFPrimitiveType
	 *     EFAndExpression returns EFPrimitiveType
	 *     EFAndExpression.EFAndExpression_1_0 returns EFPrimitiveType
	 *     EFEqualExpression returns EFPrimitiveType
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFPrimitiveType
	 *     EFRelExpression returns EFPrimitiveType
	 *     EFRelExpression.EFRelExpression_1_0 returns EFPrimitiveType
	 *     EFUnaryExpression returns EFPrimitiveType
	 *     EFPrimaryExpression returns EFPrimitiveType
	 *     EFSelectionExpression returns EFPrimitiveType
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFPrimitiveType
	 *
	 * Constraint:
	 *     type=EFNetworkNativeType
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFPrimitiveType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_PRIMITIVE_TYPE__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_PRIMITIVE_TYPE__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getTypeEFNetworkNativeTypeEnumRuleCall_3_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFStringConstant
	 *     EFExpression returns EFStringConstant
	 *     EFAssignment returns EFStringConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFStringConstant
	 *     EFOrExpression returns EFStringConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFStringConstant
	 *     EFAndExpression returns EFStringConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFStringConstant
	 *     EFEqualExpression returns EFStringConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFStringConstant
	 *     EFRelExpression returns EFStringConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFStringConstant
	 *     EFUnaryExpression returns EFStringConstant
	 *     EFPrimaryExpression returns EFStringConstant
	 *     EFSelectionExpression returns EFStringConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFStringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFStringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getValueSTRINGTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFSuper
	 *     EFExpression returns EFSuper
	 *     EFAssignment returns EFSuper
	 *     EFAssignment.EFAssignment_1_0 returns EFSuper
	 *     EFOrExpression returns EFSuper
	 *     EFOrExpression.EFOrExpression_1_0 returns EFSuper
	 *     EFAndExpression returns EFSuper
	 *     EFAndExpression.EFAndExpression_1_0 returns EFSuper
	 *     EFEqualExpression returns EFSuper
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFSuper
	 *     EFRelExpression returns EFSuper
	 *     EFRelExpression.EFRelExpression_1_0 returns EFSuper
	 *     EFUnaryExpression returns EFSuper
	 *     EFPrimaryExpression returns EFSuper
	 *     EFSelectionExpression returns EFSuper
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFSuper
	 *
	 * Constraint:
	 *     {EFSuper}
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFSuper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFSymbolRef
	 *     EFExpression returns EFSymbolRef
	 *     EFAssignment returns EFSymbolRef
	 *     EFAssignment.EFAssignment_1_0 returns EFSymbolRef
	 *     EFOrExpression returns EFSymbolRef
	 *     EFOrExpression.EFOrExpression_1_0 returns EFSymbolRef
	 *     EFAndExpression returns EFSymbolRef
	 *     EFAndExpression.EFAndExpression_1_0 returns EFSymbolRef
	 *     EFEqualExpression returns EFSymbolRef
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFSymbolRef
	 *     EFRelExpression returns EFSymbolRef
	 *     EFRelExpression.EFRelExpression_1_0 returns EFSymbolRef
	 *     EFUnaryExpression returns EFSymbolRef
	 *     EFPrimaryExpression returns EFSymbolRef
	 *     EFSelectionExpression returns EFSymbolRef
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFSymbolRef
	 *
	 * Constraint:
	 *     symbol=QualifiedName
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFSymbolRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_SYMBOL_REF__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_SYMBOL_REF__SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getSymbolQualifiedNameParserRuleCall_18_1_0(), semanticObject.getSymbol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFThis
	 *     EFExpression returns EFThis
	 *     EFAssignment returns EFThis
	 *     EFAssignment.EFAssignment_1_0 returns EFThis
	 *     EFOrExpression returns EFThis
	 *     EFOrExpression.EFOrExpression_1_0 returns EFThis
	 *     EFAndExpression returns EFThis
	 *     EFAndExpression.EFAndExpression_1_0 returns EFThis
	 *     EFEqualExpression returns EFThis
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFThis
	 *     EFRelExpression returns EFThis
	 *     EFRelExpression.EFRelExpression_1_0 returns EFThis
	 *     EFUnaryExpression returns EFThis
	 *     EFPrimaryExpression returns EFThis
	 *     EFSelectionExpression returns EFThis
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFThis
	 *
	 * Constraint:
	 *     {EFThis}
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFThis semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFTransportProtocolConstant
	 *     EFExpression returns EFTransportProtocolConstant
	 *     EFAssignment returns EFTransportProtocolConstant
	 *     EFAssignment.EFAssignment_1_0 returns EFTransportProtocolConstant
	 *     EFOrExpression returns EFTransportProtocolConstant
	 *     EFOrExpression.EFOrExpression_1_0 returns EFTransportProtocolConstant
	 *     EFAndExpression returns EFTransportProtocolConstant
	 *     EFAndExpression.EFAndExpression_1_0 returns EFTransportProtocolConstant
	 *     EFEqualExpression returns EFTransportProtocolConstant
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFTransportProtocolConstant
	 *     EFRelExpression returns EFTransportProtocolConstant
	 *     EFRelExpression.EFRelExpression_1_0 returns EFTransportProtocolConstant
	 *     EFUnaryExpression returns EFTransportProtocolConstant
	 *     EFPrimaryExpression returns EFTransportProtocolConstant
	 *     EFSelectionExpression returns EFTransportProtocolConstant
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFTransportProtocolConstant
	 *
	 * Constraint:
	 *     protocol=TRANSPORTLAYERPROTOCOL
	 * </pre>
	 */
	protected void sequence_EFPrimaryExpression(ISerializationContext context, EFTransportProtocolConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_TRANSPORT_PROTOCOL_CONSTANT__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_TRANSPORT_PROTOCOL_CONSTANT__PROTOCOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFPrimaryExpressionAccess().getProtocolTRANSPORTLAYERPROTOCOLEnumRuleCall_6_1_0(), semanticObject.getProtocol());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFRelExpression
	 *     EFExpression returns EFRelExpression
	 *     EFAssignment returns EFRelExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFRelExpression
	 *     EFOrExpression returns EFRelExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFRelExpression
	 *     EFAndExpression returns EFRelExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFRelExpression
	 *     EFEqualExpression returns EFRelExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFRelExpression
	 *     EFRelExpression returns EFRelExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFRelExpression
	 *
	 * Constraint:
	 *     (left=EFRelExpression_EFRelExpression_1_0 right=EFUnaryExpression)
	 * </pre>
	 */
	protected void sequence_EFRelExpression(ISerializationContext context, EFRelExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_REL_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFRelExpressionAccess().getEFRelExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEFRelExpressionAccess().getRightEFUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFReturn
	 *     EFReturn returns EFReturn
	 *
	 * Constraint:
	 *     expression=EFExpression
	 * </pre>
	 */
	protected void sequence_EFReturn(ISerializationContext context, EFReturn semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_RETURN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_RETURN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFReturnAccess().getExpressionEFExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFRuleClass returns EFRuleClass
	 *
	 * Constraint:
	 *     (name=ID type=EFRulesTypes members+=EFMember*)
	 * </pre>
	 */
	protected void sequence_EFRuleClass(ISerializationContext context, EFRuleClass semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFRule returns EFRule
	 *
	 * Constraint:
	 *     rules=EFRuleClass
	 * </pre>
	 */
	protected void sequence_EFRule(ISerializationContext context, EFRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_RULE__RULES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_RULE__RULES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFRuleAccess().getRulesEFRuleClassParserRuleCall_0(), semanticObject.getRules());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFSelectionExpression returns EFMemberSelection
	 *     EFSelectionExpression.EFMemberSelection_1_0 returns EFMemberSelection
	 *
	 * Constraint:
	 *     (receiver=EFSelectionExpression_EFMemberSelection_1_0 member=[EFMember|ID] (args+=EFExpression args+=EFExpression*)?)
	 * </pre>
	 */
	protected void sequence_EFSelectionExpression(ISerializationContext context, EFMemberSelection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFParameter returns EFParameter
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType))
	 * </pre>
	 */
	protected void sequence_EFTypedDeclaration(ISerializationContext context, EFParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFVariableDeclaration returns EFVariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType) expression=EFExpression)
	 * </pre>
	 */
	protected void sequence_EFTypedDeclaration_EFVariableDeclaration(ISerializationContext context, EFVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFStatement returns EFNotExpression
	 *     EFExpression returns EFNotExpression
	 *     EFAssignment returns EFNotExpression
	 *     EFAssignment.EFAssignment_1_0 returns EFNotExpression
	 *     EFOrExpression returns EFNotExpression
	 *     EFOrExpression.EFOrExpression_1_0 returns EFNotExpression
	 *     EFAndExpression returns EFNotExpression
	 *     EFAndExpression.EFAndExpression_1_0 returns EFNotExpression
	 *     EFEqualExpression returns EFNotExpression
	 *     EFEqualExpression.EFEqualExpression_1_0 returns EFNotExpression
	 *     EFRelExpression returns EFNotExpression
	 *     EFRelExpression.EFRelExpression_1_0 returns EFNotExpression
	 *     EFUnaryExpression returns EFNotExpression
	 *
	 * Constraint:
	 *     expression=EFUnaryExpression
	 * </pre>
	 */
	protected void sequence_EFUnaryExpression(ISerializationContext context, EFNotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EF_NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EF_NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFUnaryExpressionAccess().getExpressionEFUnaryExpressionParserRuleCall_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EFfirewall returns EFfirewall
	 *
	 * Constraint:
	 *     firewall=EFFireClass
	 * </pre>
	 */
	protected void sequence_EFfirewall(ISerializationContext context, EFfirewall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EasyWallPackage.Literals.EFFIREWALL__FIREWALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EasyWallPackage.Literals.EFFIREWALL__FIREWALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEFfirewallAccess().getFirewallEFFireClassParserRuleCall_0(), semanticObject.getFirewall());
		feeder.finish();
	}
	
	
}
