grammar org.xtext.example.easywall.EasyWall with org.eclipse.xtext.common.Terminals

generate easyWall "http://www.xtext.org/example/easywall/EasyWall"

EFProgram:
	EFHeader (rule=EFRule | firewall=EFfirewall)
;
EFHeader:
	{EFHeader} ('pack' name=QualifiedName ';')?
	imports+=EFImports*
;
/*
 * FIREWALL
 */
EFfirewall:
	firewall=EFFireClass
;
EFImports:
	'import' importedNamespace=QualifiedNameWithWildcard ';'
;

QualifiedName:
	ID ('.' ID)*
;
QualifiedNameWithWildcard:
	QualifiedName '.*'
;
EFFireClass:
	'firewall' name=ID '{'
	members+=EFMember*
	'}'
;
EFMember:
	EFField | EFMethod
;
EFField:
	('set' | 'var') EFTypedDeclaration ';' | EFVariableDeclaration//set for constants and var for variables
;
fragment EFTypedDeclaration *:
	name=ID ':' (ruletype=[EFRuleClass|QualifiedName] | nativetype=EFNetworkNativeType)
;
enum EFNetworkNativeType:
	NETWORK='network' | IPv4='netip' | IPv6='netipv6' | PORT='netport' | PROTOCOL='protocol' | DIRECTION='direction'
;
enum EFDirectionNativeType:
	IN='in' | OUT='out'
;
EFVariableDeclaration:
	('set' | 'var') EFTypedDeclaration '=' expression=EFExpression ';'
;
EFMethod:
	'fun' EFTypedDeclaration
	'(' (params+=EFParameter (',' params+=EFParameter)*)? ')'
	body=EFBlock;
EFParameter: EFTypedDeclaration;
EFBlock:
	{EFBlock} '{' statements+=EFStatement* '}'
;
EFStatement:
	EFVariableDeclaration |
	EFReturn |
	EFExpression ';' |
	EFIfStatement
;
EFReturn:
	'return' expression=EFExpression ';'
;
EFIfStatement:
	'if' '(' expression=EFExpression ')' thenBlock=EFIfBlock
	(=>'else' elseBlock=EFIfBlock)?
;
EFIfBlock returns EFBlock:
	 statements+=EFStatement | EFBlock
;
EFExpression:
    EFAssignment
;
EFAssignment returns EFExpression:
    EFOrExpression ({EFAssignment.left=current} '=' right=EFAssignment)?
;

EFOrExpression returns EFExpression:
    EFAndExpression ({EFOrExpression.left=current} EFOr right=EFAndExpression)*
;
EFAndExpression returns EFExpression:
    EFEqualExpression ({EFAndExpression.left=current} EFAnd right=EFEqualExpression)*
;
EFEqualExpression returns EFExpression:
    EFRelExpression ({EFEqualExpression.left=current} EFEqualOperators right=EFRelExpression)*
;
EFRelExpression returns EFExpression:
    EFUnaryExpression ({EFRelExpression.left=current} EFRelOperators right=EFUnaryExpression)*
;

EFUnaryExpression returns EFExpression:
    {EFNotExpression} EFNot expression=EFUnaryExpression | EFPrimaryExpression
;
EFPrimaryExpression returns EFExpression:
    {EFStringConstant} value=STRING
  | {EFIntConstant} value=INT
  | {EFBoolConstant} value=('true'|'false')
  | {EFPrimitiveType} type=EFNetworkNativeType
  | {EFDirectionConstant} direction=EFDirectionNativeType
  | {EFNetworkProtocolConstant} protocol=NETWORKLAYERPROTOCOL
  | {EFTransportProtocolConstant} protocol=TRANSPORTLAYERPROTOCOL
  |	{EFApplicationProtocolConstant} protocol=APPLICATIONLAYERPROTOCOL
  | {EFIPv6Constant} ipv6=EFIPV6SYNTAX
  | {EFIPv4Constant} ipv4=EFIPv4SYNTAX
  | {EFNetworkConstant} network=EFNetworkSYNTAX
  | {EFNetportConstant} port=EFNetportSYNTAX
  | {EFThis} 'this'
  | {EFSuper} 'super'
  | {EFNew} 'new' type=[EFRuleClass|QualifiedName] '(' ')'
  | {EFBRacketsExpression} '(' expression=EFExpression ')'
  | {EFFunctionCall} functionName=QualifiedName '(' (args+=EFExpression (',' args+=EFExpression)*)? ')'
  | {EFSymbolRef} symbol=QualifiedName
;
EFSelectionExpression returns EFExpression:
    EFPrimaryExpression
    (
        {EFMemberSelection.receiver=current} '->'
        member=[EFMember]
        ( '(' (args+=EFExpression (',' args+=EFExpression)*)? ')' )?
    )*
;
/*
 * RULES
 */
EFRule:
	rules=EFRuleClass
;
EFRuleClass:
	'rule' name=ID 'at' type=EFRulesTypes '{'
	members+=EFMember*
	'}'
;
enum EFRulesTypes:
	IPLEVEL='NetworkLayer' | TRANSPLEVEL='TransportLayer' | APPLEVEL='ApplicationLayer'
;
EFOr: '||' | 'or';
EFAnd: '&&' | 'and';
EFNot: '!' | 'not';
EFEqualOperators: '==' | '!=' | 'isequalto';
EFRelOperators: '>=' | '<=' | '>' | '<' ;

enum NETWORKLAYERPROTOCOL:
	IPv4='IPv4'		|
	IPv6="IPv6"		|
	ARP='ARP' 		|
	ICMP='ICMP'		|
	NAT='NAT'		|
	RIP='RIP' 		| 	//Routing Information Protocol
	OSPF='OSPF'	  	| 	//Open Shortest Path Protocol
	IPSEC='IPSEC' 	|	//Internet Protocol Security
	IGMP='IGMP'
;

enum TRANSPORTLAYERPROTOCOL:
	UDP='UDP' 	|
	TCP='TCP' 	|
	QUIC='QUIC' 	|
	SCTP	='SCTP'	//Stream Control Transmission Protocol
;

enum APPLICATIONLAYERPROTOCOL:
	HTTP='HTTP' 		|
	HTTPS='HTTPS'	|
	SMTP='SMTP'		|
	POP3='POP3'		|
	IMAP='IMAP'		|
	FTP='FTP'		|
	TFTP='TFTP'		|
	SNMP='SNMP'		|
	TELNET='TELNET'	|
	SSH='SSH'		|
	DNS='DNS'		|
	DHCP='DHCP'
;

EFIPv4SYNTAX returns EFExpression: (first=INT '.' second=INT '.' third=INT '.' fourth=INT) | any='any' | localhost='localhost';
terminal EFIPV6SYNTAX:
	 ('0'..'9'|'a'..'f'|'A'..'F')+ (':' ('0'..'9'|'a'..'f'|'A'..'F')+)+
	//{EFIPv6}(D0|D1|D2|D3|D4|D5|D6|D7|D8|D9|A|B|C|D|E|F|':')+
;
EFNetworkSYNTAX returns EFExpression: EFRAWNETSYNTAX | EFVARNETSYNTAX | EFRAWIPVARNETSYNTAX | EFVARIPRAWNETSYNTAX;
EFRAWNETSYNTAX returns EFExpression: rawip=EFIPv4SYNTAX '/'rawnetmask=INT;
EFVARNETSYNTAX returns EFExpression: varip=ID '/' varnetmask=ID;
EFRAWIPVARNETSYNTAX returns EFExpression: rawip=EFIPv4SYNTAX '/' varnetmask=ID;
EFVARIPRAWNETSYNTAX returns EFExpression: varip=ID '/' rawnetmask=INT;
EFNetportSYNTAX returns EFExpression: ':'netport=INT;